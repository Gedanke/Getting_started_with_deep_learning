# 感知机的实现

## 简单实现

我们使用 Python 来实现上节的逻辑电路。
```python
def AND(x1, x2):
    # 选择合适的参数即可
    w1, w2, thera = 0.5, 0.5, 0.7
    y = x1*w1 + x2*w2
    if y <= thera:
        return 0
    else:
        return 1
```
$w_{1},w_{2},theta$ 的取值不唯一。
<br>
来测试一下:
```python
print("AND(0,0) : " + str(AND(0, 0)))
print("AND(1,0) : " + str(AND(1, 0)))
print("AND(0,1) : " + str(AND(0, 1)))
print("AND(1,1) : " + str(AND(1, 1)))
```
结果为：
```
AND(0,0) : 0
AND(1,0) : 0
AND(0,1) : 0
AND(1,1) : 1
```
这样，我们就实现了与门，稍加改造，其他逻辑电路也不在话下了。

## 导入权重和偏置
现在，我们将之前的表达式换一种形式，如下：
$$
y  =
\begin{cases}
0   & \text{ $b+x_{1}w_{1} + x_{2}w_{2}\leq 0 $} \\
1   & \text{ $b+ x_{1}w_{1} + x_{2}w_{2}>0$ }
\end{cases}
$$
和之前的其实一样，无非换了个符号。
这里，$b$ 为偏置，$w_{1}$ 和 $w_{2}$ 为权重。
信号乘以对于的权重之和再加上偏置，大于0输出1，否则输出0。

下面，我们使用 NumPy 来实现感知机。
```python
import numpy as np

# 输入
x = np.array([0, 1])
# 权重
w = np.array([0.5, 0.5])
# 偏置
b = -0.7
print(w*x)
print(np.sum(w*x))
print(np.sum(w*x) + b)
```
结果为：
```
[0.  0.5]
0.5
-0.19999999999999996
```
最后一个是由浮点数造成的误差。
<br>
我们使用两个数组相乘加上偏置，同样也实现了感知机模型。

## 使用权重和偏置的实现

使用权重和偏置，可以实现与门：
```python
def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    y = np.sum(w*x) + b
    if y <= 0:
        return 0
    else:
        return 1
```
偏置和权重的作用是不一样的。$w_{1}$ 和 $w_{2}$ 是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度(输出信号为1的程度)的参数。偏置的值决定了神经元被激活的容易程度。
此外，我们将 $w_{1}$ 和 $w_{2}$ 称为权重，将 $b$ 称为偏置，有时候它们会被统称为权重。

以下一段来自于原文：
<br>
偏置这个术语，有“穿木屐”的效果，即在没有任何输入时(输入为 
0 时)，给输出穿上多高的木屐(加上多大的值)的意思。实际上，在上式 $b+ x_{1}w_{1} + x_{2}w_{2}$ 的计算中，当输入 $x_{1}$ 和$x_{2}$ 为 0 时，只输出偏置的值。

接下来，我们来实现与非门和或门。
<br>
与非门：
```python
def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5]) # 仅权重和偏置与AND不同！
    b = 0.7
    y = np.sum(w*x) + b
    if y <= 0:
        return 0
    else:
        return 1
```
或门：
```python
def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])  # 仅权重和偏置与AND不同！
    b = -0.2
    y = np.sum(w*x) + b
    if y <= 0:
        return 0
    else:
        return 1
```
用感知机实现这些逻辑电路时，不同点只是权重和偏置的不同，它们都有着共同的结构。